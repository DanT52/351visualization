<!DOCTYPE html>
<html>

<head>
  <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
</head>

<body>
  <script type="module">
      import { bbcCompress } from "./compression.js?version=1";
      console.log(bbcCompress(1,2));
  </script>
  <script>
    //store compressed chunks in array and them put together at the end
    function createTypedArray(wordSize, numChunks) {
      switch (wordSize) {
        case 8:
          return new Uint8Array(numChunks); // 1 byte per chunk
        case 16:
          return new Uint16Array(numChunks); // 2 bytes per chunk
        case 32:
          return new Uint32Array(numChunks); // 4 bytes per chunk
        case 64:
          return new BigInt64Array(numChunks); // 8 bytes per chunk
        default:
          throw new Error("Unsupported word size. Choose 8, 16, 32, or 64.");
      }
    }


    function getCompression(numRuns, runOf, chunkarr, word_size, compressed, index) {
      if (numRuns != 0) {
        let header = 1 << (word_size - 1);
        if (runOf == 1) {
          header |= 1 << (word_size - 2)
        }
        numRuns |= header
        compressed[index] = numRuns
      }
      else { //literal
        compressed[index] = chunkarr
      }

    }


    function wah(string, word_size) {
      let numChunks = Math.ceil(string.length / (word_size - 1))
      let index = 0

      let compressed = createTypedArray(word_size, numChunks);
      const parseFn = word_size > 32 ? (str) => BigInt("0b" + str) : (str) => parseInt(str, 2);
      const castFn = word_size > 32 ? BigInt : (x) => x;

      let runOnes = 0
      let runZeros = 0
      let chunkSize = word_size - 1
      let onesNum = castFn((1 << chunkSize) - 1)
      let lastchunkflg = 0


      for (let i = 0; i < string.length; i += chunkSize) {
        let chunkStr = string.slice(i, i + chunkSize);
        let chunk = parseFn(chunkStr);
        if (i + chunkSize >= string.length) {
          chunk = chunk << castFn(word_size - 1 - chunkStr.length)
          lastchunkflg = 1
        }

        if (chunk == 0 && lastchunkflg == 0) {
          if (runOnes > 0) { //RUN OF 1's ended, run of 0's started
            getCompression(runOnes, 1, null, word_size, compressed, index++)
            runOnes = 0
          }
          runZeros++  //"RUN OF 0's

        }
        else if ((chunk & onesNum) == onesNum) {//RUN OF 1's
          if (runZeros > 0) {
            getCompression(runZeros, 0, null, word_size, compressed, index++)
            runZeros = 0
          }
          runOnes++
        }
        else {
          if (runOnes > 0) {//encode run of 1s first
            getCompression(runOnes, 1, null, word_size, compressed, index++)
            runOnes = 0
          }
          else if (runZeros > 0) {//encode run of 0s first
            getCompression(runZeros, 0, null, word_size, compressed, index++)
            runZeros = 0
          }
          // encode Literal
          getCompression(0, 0, chunk, word_size, compressed, index++)
        }


      }

      if (runOnes > 0) {//encode run of 1"
        getCompression(runOnes, 1, null, word_size, compressed, index++)
      }
      else if (runZeros > 0) {//encode run of 0
        getCompression(runZeros, 0, null, word_size, compressed, index++)
      }

      return {
        compressed,
        length: index,
      }
    }

    function bitsToString(compressed, length, wordSize) {
      return Array.from(compressed).slice(0, length).map(num => num.toString(2).padStart(wordSize, '0')).join('');
    }
  </script>
  <script type="module">
    import { wahCompress, valCompress, valDecompress, getValSegmentLength } from "./compression.js";

    const wordSize = 64;
    const valSegmentCount = 2;
    const index = "1000110000001001010010000010100000101000000111000100000000000000000000001001000000111011000001100000000001101001000000011001000001010001100101000001000100010000100000100111000000000001000000010000001000100001011010010000010000001000101000010001010000110000010000010110000001000000000000000001101000110000001101000000100100100000000000000001010011000111000000000010000001010000100010010000000001010100100000001100001000001000000010000011001000010100011100001000010000000000011000101000100011010101100000011000000001001000010100000000000000001000010000010001010010001000000001010011000010000000000010000001100001000100000100000000000000110000001100100000111000101001000000001000111000111000000000000001110001001001001000000011001000111010001100000100101000000000100110010010000000000100010010010001100010110110000110110000000000000100000111000000101110000010000000100100000000001010000000000100111001111000100100001000001101000000000010011101000000000010100100001011010001110000000000000010010000000100";

    {
      console.log(`Wah w/ ${wordSize}bit word size:`);
      const start = performance.now();
      const result = wah(index, wordSize);
      const end = performance.now();
      console.log(`Compressed index in ${end - start}ms`);
      console.log(bitsToString(result.compressed, result.length, wordSize));
    }

    {
      console.log(`Other wah w/ ${wordSize}bit word size:`);

      const start = performance.now();
      const result = wahCompress(index, wordSize);
      const end = performance.now();
      console.log(`Compressed index in ${end - start}ms`);
      console.log(bitsToString(result.compressed, result.length, wordSize));
    }

    {
      console.log(`Val w/ ${wordSize}bit word size and ${valSegmentCount} segments:`);

      const start = performance.now();
      const result = valCompress(index, wordSize, valSegmentCount);
      const end = performance.now();
      console.log(`Compressed index in ${end - start}ms`);
      console.log(bitsToString(result.compressed, result.length, wordSize));

      console.log("Decompressing val (should be same as input, except for any zero padding at the end):")
      const decompressed = valDecompress(result.compressed, result.length, wordSize, valSegmentCount);
      console.log(bitsToString(decompressed, decompressed.length, getValSegmentLength(wordSize, valSegmentCount)));
    }

    {
      console.log("Tiny val example from the slides:");

      const start = performance.now();
      const result = valCompress("101000111111111111111", 16, 2);
      const end = performance.now();
      console.log(`Compressed index in ${end - start}ms`);
      console.log(bitsToString(result.compressed, result.length, 16));
    }
  </script>
</body>

</html>
